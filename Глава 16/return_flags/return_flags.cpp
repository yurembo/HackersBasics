// return_flags.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <stdio.h>

// Функция сообщения об ошибке деления 
void Err()
{ 
	printf("-ERR: DIV by Zero\n");
}

// Вывод результата деления на экран 
void Ok(int a)
{
	printf("%x\n", a);
}

// Ассемблерная функция деления.
// Делит EAX на EBX, возвращая частное в EAX, а остаток - в EDX 
// При попытке деления на ноль устанавливает флаг переноса
__declspec(naked) int MyFunc()
{
	__asm
	{
		xor edx, edx;  Обнуляем EDX, т.е.команда div ожидает делимого в EAX.
		test ebx, ebx; Проверка делителя на равенство нулю.
		jz _err		 ; Если делитель равен нулю, перейти к ветке _err.
		div ebx		 ; Делим EAX на EBX (EBX заведомо не равен нулю).
		ret
		_err : ;  Эта ветка получает управление при попытке деления на ноль.
		stc; устанавливаем флаг переноса, сигнализируя об ошибке и...
		ret; выходим.
	}
} 

// Обертка для MyFunc.
// Принимаем два аргумента через стек - делимое и делитель - 
// и выводим результат деления (или сообщение об ошибке) на зкран
__declspec(naked) void MyFunc_2(int a, int b)
{
	__asm
	{
		mov eax, [esp + 4];  Загружаем в EAX содержимое аргумента a
		mov ebx, [esp + 8];  Загружаем в EBX содержимое аргумента b.
		call MyFunc;  Пытаемся делить a / b.
		jnc _ok; Если флаг переноса сброшен, выводим результат, иначе...
		call Err; сообщение об ошибке.
		ret; Возвращаемся
		_ok :
			push eax ; Передаем результат деления и...
			call Ok  ; выводим его на зкран.
			add esp,4; Вычищаем за собой стек.
			ret		 ;Возвращаемся.
	}
}

int main() 
{ 
	MyFunc_2(4, 0); 
}